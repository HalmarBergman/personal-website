import { fileURLToPath } from 'node:url';
import { normalize, resolve } from 'pathe';
import { defineNuxtModule, addServerHandler } from '@nuxt/kit';
import defu, { createDefu } from 'defu';

const DEFAULT_GLOBAL_ROUTE = "/**";
const DEFAULT_MIDDLEWARE_ROUTE = "";
const defaultGlobalRoute = { route: DEFAULT_GLOBAL_ROUTE };
const defaultMiddlewareRoute = { route: DEFAULT_MIDDLEWARE_ROUTE };
const defaultThrowErrorValue = { throwError: true };
const defaultSecurityConfig = {
  headers: {
    crossOriginResourcePolicy: {
      value: "same-origin",
      ...defaultGlobalRoute
    },
    crossOriginOpenerPolicy: {
      value: "same-origin",
      ...defaultGlobalRoute
    },
    crossOriginEmbedderPolicy: {
      value: "require-corp",
      ...defaultGlobalRoute
    },
    contentSecurityPolicy: {
      value: {
        "base-uri": ["'self'"],
        "font-src": ["'self'", "https:", "data:"],
        "form-action": ["'self'"],
        "frame-ancestors": ["'self'"],
        "img-src": ["'self'", "data:"],
        "object-src": ["'none'"],
        "script-src-attr": ["'none'"],
        "style-src": ["'self'", "https:", "'unsafe-inline'"],
        "upgrade-insecure-requests": true
      },
      ...defaultGlobalRoute
    },
    originAgentCluster: {
      value: "?1",
      ...defaultGlobalRoute
    },
    referrerPolicy: {
      value: "no-referrer",
      ...defaultGlobalRoute
    },
    strictTransportSecurity: {
      value: {
        maxAge: 15552e3,
        includeSubdomains: true
      },
      ...defaultGlobalRoute
    },
    xContentTypeOptions: {
      value: "nosniff",
      ...defaultGlobalRoute
    },
    xDNSPrefetchControl: {
      value: "off",
      ...defaultGlobalRoute
    },
    xDownloadOptions: {
      value: "noopen",
      ...defaultGlobalRoute
    },
    xFrameOptions: {
      value: "SAMEORIGIN",
      ...defaultGlobalRoute
    },
    xPermittedCrossDomainPolicies: {
      value: "none",
      ...defaultGlobalRoute
    },
    xXSSProtection: {
      value: "0",
      ...defaultGlobalRoute
    }
  },
  requestSizeLimiter: {
    value: {
      maxRequestSizeInBytes: 2e6,
      maxUploadFileRequestInBytes: 8e6
    },
    ...defaultMiddlewareRoute,
    ...defaultThrowErrorValue
  },
  rateLimiter: {
    value: {
      tokensPerInterval: 150,
      interval: "hour",
      fireImmediately: true
    },
    ...defaultMiddlewareRoute,
    ...defaultThrowErrorValue
  },
  xssValidator: {
    value: {},
    ...defaultMiddlewareRoute,
    ...defaultThrowErrorValue
  },
  corsHandler: {
    value: {
      origin: "*",
      methods: ["GET", "HEAD", "PUT", "PATCH", "POST", "DELETE"],
      preflight: {
        statusCode: 204
      }
    },
    ...defaultMiddlewareRoute,
    ...defaultThrowErrorValue
  },
  allowedMethodsRestricter: {
    value: "*",
    ...defaultMiddlewareRoute,
    ...defaultThrowErrorValue
  },
  hidePoweredBy: true,
  basicAuth: false,
  enabled: true
};

const SECURITY_HEADER_NAMES = {
  contentSecurityPolicy: "Content-Security-Policy",
  crossOriginEmbedderPolicy: "Cross-Origin-Embedder-Policy",
  crossOriginOpenerPolicy: "Cross-Origin-Opener-Policy",
  crossOriginResourcePolicy: "Cross-Origin-Resource-Policy",
  originAgentCluster: "Origin-Agent-Cluster",
  referrerPolicy: "Referrer-Policy",
  strictTransportSecurity: "Strict-Transport-Security",
  xContentTypeOptions: "X-Content-Type-Options",
  xDNSPrefetchControl: "X-DNS-Prefetch-Control",
  xDownloadOptions: "X-Download-Options",
  xFrameOptions: "X-Frame-Options",
  xPermittedCrossDomainPolicies: "X-Permitted-Cross-Domain-Policies",
  xXSSProtection: "X-XSS-Protection"
};
const headerValueMappers = {
  strictTransportSecurity: (value) => [
    `max-age=${value.maxAge}`,
    value.includeSubdomains && "includeSubDomains",
    value.preload && "preload"
  ].filter(Boolean).join("; "),
  contentSecurityPolicy: (value) => {
    return Object.entries(value).map(([directive, sources]) => {
      if (directive === "upgrade-insecure-requests") {
        return sources ? "upgrade-insecure-requests" : "";
      }
      return sources?.length && `${directive} ${sources.join(" ")}`;
    }).filter(Boolean).join("; ");
  }
};
const getHeaderValueFromOptions = (headerType, headerOptions) => {
  if (typeof headerOptions.value === "string") {
    return headerOptions.value;
  }
  return headerValueMappers[headerType]?.(headerOptions.value) ?? headerOptions.value;
};

const defuReplaceArray = createDefu((obj, key, value) => {
  if (Array.isArray(obj[key]) || Array.isArray(value)) {
    obj[key] = value;
    return true;
  }
});
const module = defineNuxtModule({
  meta: {
    name: "nuxt-security",
    configKey: "security"
  },
  setup(options, nuxt) {
    const runtimeDir = fileURLToPath(new URL("./runtime", import.meta.url));
    nuxt.options.build.transpile.push(runtimeDir);
    nuxt.options.security = defuReplaceArray(nuxt.options.security, {
      ...defaultSecurityConfig
    });
    const securityOptions = nuxt.options.security;
    if (!securityOptions.enabled)
      return;
    if (securityOptions.hidePoweredBy) {
      nuxt.hook("nitro:config", (config) => {
        config.plugins = config.plugins || [];
        config.externals = config.externals || {};
        config.externals.inline = config.externals.inline || [];
        config.externals.inline.push(normalize(fileURLToPath(new URL("./runtime", import.meta.url))));
        config.plugins.push(
          normalize(fileURLToPath(new URL("./runtime/nitro", import.meta.url)))
        );
      });
    }
    nuxt.options.runtimeConfig.security = defu(nuxt.options.runtimeConfig.security, {
      ...securityOptions
    });
    if (securityOptions.headers) {
      for (const header in securityOptions.headers) {
        if (securityOptions.headers[header]) {
          const nitroRouteRules = nuxt.options.nitro.routeRules;
          const headerOptions = securityOptions.headers[header];
          nitroRouteRules[headerOptions.route] = {
            ...nitroRouteRules[headerOptions.route],
            headers: {
              ...nitroRouteRules[headerOptions.route]?.headers,
              [SECURITY_HEADER_NAMES[header]]: getHeaderValueFromOptions(header, headerOptions)
            }
          };
        }
      }
    }
    const requestSizeLimiterConfig = nuxt.options.security.requestSizeLimiter;
    if (requestSizeLimiterConfig) {
      addServerHandler({
        route: requestSizeLimiterConfig.route,
        handler: normalize(
          resolve(runtimeDir, "server/middleware/requestSizeLimiter")
        )
      });
    }
    const rateLimiterConfig = securityOptions.rateLimiter;
    if (rateLimiterConfig) {
      addServerHandler({
        route: rateLimiterConfig.route,
        handler: normalize(
          resolve(runtimeDir, "server/middleware/rateLimiter")
        )
      });
    }
    const xssValidatorConfig = nuxt.options.security.xssValidator;
    if (xssValidatorConfig) {
      addServerHandler({
        route: xssValidatorConfig.route,
        handler: normalize(
          resolve(runtimeDir, "server/middleware/xssValidator")
        )
      });
    }
    const corsHandlerConfig = nuxt.options.security.corsHandler;
    if (corsHandlerConfig) {
      addServerHandler({
        route: corsHandlerConfig.route,
        handler: normalize(
          resolve(runtimeDir, "server/middleware/corsHandler")
        )
      });
    }
    const allowedMethodsRestricterConfig = nuxt.options.security.allowedMethodsRestricter;
    if (allowedMethodsRestricterConfig && allowedMethodsRestricterConfig.value !== "*") {
      addServerHandler({
        route: allowedMethodsRestricterConfig.route,
        handler: normalize(
          resolve(runtimeDir, "server/middleware/allowedMethodsRestricter")
        )
      });
    }
    const basicAuthConfig = nuxt.options.security.basicAuth;
    if (basicAuthConfig && basicAuthConfig?.value?.enabled) {
      addServerHandler({
        route: basicAuthConfig.route,
        handler: normalize(resolve(runtimeDir, "server/middleware/basicAuth"))
      });
    }
  }
});

export { module as default };
